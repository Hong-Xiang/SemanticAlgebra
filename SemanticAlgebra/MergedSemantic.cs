//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using SemanticAlgebra.Data;

namespace SemanticAlgebra;

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2>, TS1, TS2    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2>
    : IMergedSemantic1<TMS, TS1, TS2>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2>, TS1, TS2    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3>, TS1, TS2, TS3    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3>
    : IMergedSemantic1<TMS, TS1, TS2, TS3>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3>, TS1, TS2, TS3    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3,
    TS4> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4>, TS1, TS2, TS3, TS4    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
    where TS4 : IFunctor<TS4>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3,
        ISemantic1<TS4, TS, TR> s4
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f),
            TS4.Compose((ISemantic1<TS4, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS4.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS4.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3,
    TS4>
    : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3, TS4>, TS1, TS2, TS3, TS4    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
    where TS4 : IImplements<TS4, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get(),
            TS4.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5>, TS1, TS2, TS3, TS4, TS5    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
    where TS4 : IFunctor<TS4>
    where TS5 : IFunctor<TS5>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3,
        ISemantic1<TS4, TS, TR> s4,
        ISemantic1<TS5, TS, TR> s5
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f),
            TS4.Compose((ISemantic1<TS4, TS, TI>)s, f),
            TS5.Compose((ISemantic1<TS5, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS4.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS5.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS4.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS5.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5>
    : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3, TS4, TS5>, TS1, TS2, TS3, TS4, TS5    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
    where TS4 : IImplements<TS4, TAlg, T>
    where TS5 : IImplements<TS5, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get(),
            TS4.Get(),
            TS5.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6>, TS1, TS2, TS3, TS4, TS5, TS6    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
    where TS4 : IFunctor<TS4>
    where TS5 : IFunctor<TS5>
    where TS6 : IFunctor<TS6>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3,
        ISemantic1<TS4, TS, TR> s4,
        ISemantic1<TS5, TS, TR> s5,
        ISemantic1<TS6, TS, TR> s6
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f),
            TS4.Compose((ISemantic1<TS4, TS, TI>)s, f),
            TS5.Compose((ISemantic1<TS5, TS, TI>)s, f),
            TS6.Compose((ISemantic1<TS6, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS4.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS5.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS6.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS4.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS5.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS6.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6>
    : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3, TS4, TS5, TS6>, TS1, TS2, TS3, TS4, TS5, TS6    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
    where TS4 : IImplements<TS4, TAlg, T>
    where TS5 : IImplements<TS5, TAlg, T>
    where TS6 : IImplements<TS6, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get(),
            TS4.Get(),
            TS5.Get(),
            TS6.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7>, TS1, TS2, TS3, TS4, TS5, TS6, TS7    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
    where TS4 : IFunctor<TS4>
    where TS5 : IFunctor<TS5>
    where TS6 : IFunctor<TS6>
    where TS7 : IFunctor<TS7>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3,
        ISemantic1<TS4, TS, TR> s4,
        ISemantic1<TS5, TS, TR> s5,
        ISemantic1<TS6, TS, TR> s6,
        ISemantic1<TS7, TS, TR> s7
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f),
            TS4.Compose((ISemantic1<TS4, TS, TI>)s, f),
            TS5.Compose((ISemantic1<TS5, TS, TI>)s, f),
            TS6.Compose((ISemantic1<TS6, TS, TI>)s, f),
            TS7.Compose((ISemantic1<TS7, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS4.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS5.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS6.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS7.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS4.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS5.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS6.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS7.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7>
    : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3, TS4, TS5, TS6, TS7>, TS1, TS2, TS3, TS4, TS5, TS6, TS7    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
    where TS4 : IImplements<TS4, TAlg, T>
    where TS5 : IImplements<TS5, TAlg, T>
    where TS6 : IImplements<TS6, TAlg, T>
    where TS7 : IImplements<TS7, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get(),
            TS4.Get(),
            TS5.Get(),
            TS6.Get(),
            TS7.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7,
    TS8> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8>, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
    where TS4 : IFunctor<TS4>
    where TS5 : IFunctor<TS5>
    where TS6 : IFunctor<TS6>
    where TS7 : IFunctor<TS7>
    where TS8 : IFunctor<TS8>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3,
        ISemantic1<TS4, TS, TR> s4,
        ISemantic1<TS5, TS, TR> s5,
        ISemantic1<TS6, TS, TR> s6,
        ISemantic1<TS7, TS, TR> s7,
        ISemantic1<TS8, TS, TR> s8
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f),
            TS4.Compose((ISemantic1<TS4, TS, TI>)s, f),
            TS5.Compose((ISemantic1<TS5, TS, TI>)s, f),
            TS6.Compose((ISemantic1<TS6, TS, TI>)s, f),
            TS7.Compose((ISemantic1<TS7, TS, TI>)s, f),
            TS8.Compose((ISemantic1<TS8, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS4.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS5.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS6.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS7.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS8.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS4.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS5.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS6.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS7.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS8.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7,
    TS8>
    : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8>, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
    where TS4 : IImplements<TS4, TAlg, T>
    where TS5 : IImplements<TS5, TAlg, T>
    where TS6 : IImplements<TS6, TAlg, T>
    where TS7 : IImplements<TS7, TAlg, T>
    where TS8 : IImplements<TS8, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get(),
            TS4.Get(),
            TS5.Get(),
            TS6.Get(),
            TS7.Get(),
            TS8.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7,
    TS8,
    TS9> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9>, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
    where TS4 : IFunctor<TS4>
    where TS5 : IFunctor<TS5>
    where TS6 : IFunctor<TS6>
    where TS7 : IFunctor<TS7>
    where TS8 : IFunctor<TS8>
    where TS9 : IFunctor<TS9>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3,
        ISemantic1<TS4, TS, TR> s4,
        ISemantic1<TS5, TS, TR> s5,
        ISemantic1<TS6, TS, TR> s6,
        ISemantic1<TS7, TS, TR> s7,
        ISemantic1<TS8, TS, TR> s8,
        ISemantic1<TS9, TS, TR> s9
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f),
            TS4.Compose((ISemantic1<TS4, TS, TI>)s, f),
            TS5.Compose((ISemantic1<TS5, TS, TI>)s, f),
            TS6.Compose((ISemantic1<TS6, TS, TI>)s, f),
            TS7.Compose((ISemantic1<TS7, TS, TI>)s, f),
            TS8.Compose((ISemantic1<TS8, TS, TI>)s, f),
            TS9.Compose((ISemantic1<TS9, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS4.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS5.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS6.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS7.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS8.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS9.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS4.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS5.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS6.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS7.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS8.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS9.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7,
    TS8,
    TS9>
    : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9>, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
    where TS4 : IImplements<TS4, TAlg, T>
    where TS5 : IImplements<TS5, TAlg, T>
    where TS6 : IImplements<TS6, TAlg, T>
    where TS7 : IImplements<TS7, TAlg, T>
    where TS8 : IImplements<TS8, TAlg, T>
    where TS9 : IImplements<TS9, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get(),
            TS4.Get(),
            TS5.Get(),
            TS6.Get(),
            TS7.Get(),
            TS8.Get(),
            TS9.Get());
}

public interface IMergedSemantic1<
    TMS,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7,
    TS8,
    TS9,
    TS10> : IFunctor<TMS>
    where TMS : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9, TS10>, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9, TS10    where TS1 : IFunctor<TS1>
    where TS2 : IFunctor<TS2>
    where TS3 : IFunctor<TS3>
    where TS4 : IFunctor<TS4>
    where TS5 : IFunctor<TS5>
    where TS6 : IFunctor<TS6>
    where TS7 : IFunctor<TS7>
    where TS8 : IFunctor<TS8>
    where TS9 : IFunctor<TS9>
    where TS10 : IFunctor<TS10>
{
    static abstract ISemantic1<TMS, TS, TR> MergeSemantic<TS, TR>(
        ISemantic1<TS1, TS, TR> s1,
        ISemantic1<TS2, TS, TR> s2,
        ISemantic1<TS3, TS, TR> s3,
        ISemantic1<TS4, TS, TR> s4,
        ISemantic1<TS5, TS, TR> s5,
        ISemantic1<TS6, TS, TR> s6,
        ISemantic1<TS7, TS, TR> s7,
        ISemantic1<TS8, TS, TR> s8,
        ISemantic1<TS9, TS, TR> s9,
        ISemantic1<TS10, TS, TR> s10
    );

    static ISemantic1<TMS, TS, TR> IKind1<TMS>.Compose<TS, TI, TR>(
        ISemantic1<TMS, TS, TI> s, Func<TI, TR> f)
        => TMS.MergeSemantic(
            TS1.Compose((ISemantic1<TS1, TS, TI>)s, f),
            TS2.Compose((ISemantic1<TS2, TS, TI>)s, f),
            TS3.Compose((ISemantic1<TS3, TS, TI>)s, f),
            TS4.Compose((ISemantic1<TS4, TS, TI>)s, f),
            TS5.Compose((ISemantic1<TS5, TS, TI>)s, f),
            TS6.Compose((ISemantic1<TS6, TS, TI>)s, f),
            TS7.Compose((ISemantic1<TS7, TS, TI>)s, f),
            TS8.Compose((ISemantic1<TS8, TS, TI>)s, f),
            TS9.Compose((ISemantic1<TS9, TS, TI>)s, f),
            TS10.Compose((ISemantic1<TS10, TS, TI>)s, f));

    static ISemantic1<TMS, T, IS<TMS, T>> IKind1<TMS>.Id<T>()
        => TMS.MergeSemantic<T, IS<TMS, T>>(
            TS1.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS2.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS3.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS4.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS5.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS6.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS7.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS8.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS9.Id<T>().Compose(e => (IS<TMS, T>)e),
            TS10.Id<T>().Compose(e => (IS<TMS, T>)e));

    static ISemantic1<TMS, TS, IS<TMS, TR>> IFunctor<TMS>.MapS<TS, TR>(Func<TS, TR> f)
        => TMS.MergeSemantic<TS, IS<TMS, TR>>(
            TS1.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS2.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS3.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS4.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS5.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS6.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS7.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS8.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS9.MapS(f).Compose(e => (IS<TMS, TR>)e),
            TS10.MapS(f).Compose(e => (IS<TMS, TR>)e));
}

public interface IMergedSemantic1Implements<
    TMS,
    TAlg,
    T,
    TS1,
    TS2,
    TS3,
    TS4,
    TS5,
    TS6,
    TS7,
    TS8,
    TS9,
    TS10>
    : IMergedSemantic1<TMS, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9, TS10>
    , IImplements<TMS, TAlg, T>
    where TMS : IMergedSemantic1Implements<TMS, TAlg, T, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9, TS10>, TS1, TS2, TS3, TS4, TS5, TS6, TS7, TS8, TS9, TS10    where TAlg : IAlgebra<TAlg, T>
    where TS1 : IImplements<TS1, TAlg, T>
    where TS2 : IImplements<TS2, TAlg, T>
    where TS3 : IImplements<TS3, TAlg, T>
    where TS4 : IImplements<TS4, TAlg, T>
    where TS5 : IImplements<TS5, TAlg, T>
    where TS6 : IImplements<TS6, TAlg, T>
    where TS7 : IImplements<TS7, TAlg, T>
    where TS8 : IImplements<TS8, TAlg, T>
    where TS9 : IImplements<TS9, TAlg, T>
    where TS10 : IImplements<TS10, TAlg, T>
{
    static ISemantic1<TMS, T, T> IImplements<TMS, TAlg, T>.Get()
        => TMS.MergeSemantic(
            TS1.Get(),
            TS2.Get(),
            TS3.Get(),
            TS4.Get(),
            TS5.Get(),
            TS6.Get(),
            TS7.Get(),
            TS8.Get(),
            TS9.Get(),
            TS10.Get());
}



using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;

namespace SemanticAlgebra.SourceGenerator;

[Generator]
public sealed class SemanticKindSourceGenerator : IIncrementalGenerator
{
    private const string BrandAttributeFullQualifiedName = "SemanticAlgebra.Syntax.SemanticKind1Brand";

    // Diagnostic descriptors for logging
    private static readonly DiagnosticDescriptor InfoDescriptor = new DiagnosticDescriptor(
        id: "SGEN001",
        title: "Source Generator Info",
        messageFormat: "SemanticKind Source Generator: {0}",
        category: "SourceGenerator",
        DiagnosticSeverity.Info,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor DebugDescriptor = new DiagnosticDescriptor(
        id: "SGEN002",
        title: "Source Generator Debug",
        messageFormat: "SemanticKind Source Generator Debug: {0}",
        category: "SourceGenerator",
        DiagnosticSeverity.Info,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var brandClasses = context.SyntaxProvider.ForAttributeWithMetadataName(
                        BrandAttributeFullQualifiedName,
                        predicate: static (s, _) => s is ClassDeclarationSyntax or InterfaceDeclarationSyntax,
                        transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx));

        // Combine with compilation to get semantic model

        // Generate source for each class
        context.RegisterSourceOutput(brandClasses,
            static (spc, source) => Execute(source, spc));
    }

    /// <summary>
    /// Gets the semantic target for generation if it matches our criteria
    /// </summary>
    private static ClassDeclarationSyntax GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context)
    {
        return (ClassDeclarationSyntax)context.TargetNode;
    }/// <summary>
     /// Executes the source generation for the matched classes
     /// </summary>
    private static void Execute(ClassDeclarationSyntax brandClass, SourceProductionContext context)
    {
        // Log execution start
        ReportInfo(context, $"Starting source generation. Found {brandClass.Identifier} potential classes.");

        var className = brandClass.Identifier.ValueText;
        ReportDebug(context, $"Generating partial class for: {className}");
        GeneratePartialClass(context, brandClass);

        ReportInfo(context, "Source generation completed successfully.");
    }

    /// <summary>
    /// Generates a partial class with the SourceGenTest property
    /// </summary>
    private static void GeneratePartialClass(SourceProductionContext context, ClassDeclarationSyntax classDeclaration)
    {
        var namespaceName = GetNamespace(classDeclaration);
        var className = classDeclaration.Identifier.ValueText;

        var source = GenerateSourceCode(namespaceName, className);

        context.AddSource($"{className}.SourceGenTest.g.cs", source);
    }

    /// <summary>
    /// Gets the namespace of a class declaration
    /// </summary>
    private static string GetNamespace(SyntaxNode classDeclaration)
    {
        // Try to get namespace from namespace declaration
        var namespaceDeclaration = classDeclaration.Ancestors().OfType<NamespaceDeclarationSyntax>().FirstOrDefault();
        if (namespaceDeclaration != null)
        {
            return namespaceDeclaration.Name.ToString();
        }

        // Try to get from file-scoped namespace
        var fileScopedNamespace = classDeclaration.Ancestors().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
        if (fileScopedNamespace != null)
        {
            return fileScopedNamespace.Name.ToString();
        }

        return string.Empty;
    }

    /// <summary>
    /// Generates the source code for the partial class
    /// </summary>
    private static string GenerateSourceCode(string namespaceName, string className)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {className}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Auto-generated property by SemanticAlgebra Source Generator");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public string SourceGenTest { get; } = \"TestGen\";");
        sb.AppendLine("    public string SourceGenTest2 { get; } = \"TestGen\";");
        sb.AppendLine("}");

        return sb.ToString();
    }

    // Helper methods for logging to compiler output
    private static void ReportInfo(SourceProductionContext context, string message)
    {
        var diagnostic = Diagnostic.Create(InfoDescriptor, Location.None, message);
        context.ReportDiagnostic(diagnostic);
    }

    private static void ReportDebug(SourceProductionContext context, string message)
    {
        var diagnostic = Diagnostic.Create(DebugDescriptor, Location.None, message);
        context.ReportDiagnostic(diagnostic);
    }
}

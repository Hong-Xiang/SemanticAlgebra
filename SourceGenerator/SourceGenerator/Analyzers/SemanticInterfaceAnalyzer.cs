// <auto-generated />
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SemanticAlgebra.SourceGenerator.Models;
using System.Collections.Generic;
using System.Linq;

namespace SemanticAlgebra.SourceGenerator.Analyzers;

/// <summary>
/// Analyzes semantic interfaces to extract method information for code generation
/// </summary>
public static class SemanticInterfaceAnalyzer
{
    /// <summary>
    /// Analyzes an ISemantic interface to extract method information
    /// </summary>
    public static IReadOnlyList<SemanticMethodInfo> AnalyzeSemanticInterface(
        InterfaceDeclarationSyntax interfaceDeclaration,
        SemanticModel semanticModel)
    {
        var methods = new List<SemanticMethodInfo>();
        
        foreach (var member in interfaceDeclaration.Members.OfType<MethodDeclarationSyntax>())
        {
            var methodInfo = AnalyzeSemanticMethod(member, semanticModel);
            if (methodInfo != null)
            {
                methods.Add(methodInfo);
            }
        }
        
        return methods;
    }
    
    /// <summary>
    /// Analyzes a single method in a semantic interface
    /// </summary>
    private static SemanticMethodInfo? AnalyzeSemanticMethod(
        MethodDeclarationSyntax methodDeclaration,
        SemanticModel semanticModel)
    {
        var methodName = methodDeclaration.Identifier.ValueText;
        var parameters = new List<SemanticParameterInfo>();
        
        // Analyze parameters
        foreach (var parameter in methodDeclaration.ParameterList.Parameters)
        {
            var parameterInfo = AnalyzeParameter(parameter, semanticModel);
            if (parameterInfo != null)
            {
                parameters.Add(parameterInfo);
            }
        }
        
        // Analyze return type
        var returnTypeName = GetReturnTypeName(methodDeclaration.ReturnType, semanticModel);
        var hasGenericTypeParameter = HasGenericTypeParameter(methodDeclaration, semanticModel);
        
        return new SemanticMethodInfo(
            methodName,
            parameters,
            returnTypeName,
            hasGenericTypeParameter);
    }
    
    /// <summary>
    /// Analyzes a method parameter
    /// </summary>
    private static SemanticParameterInfo? AnalyzeParameter(
        ParameterSyntax parameter,
        SemanticModel semanticModel)
    {
        if (parameter.Type == null || parameter.Identifier.ValueText == "")
            return null;
            
        var parameterName = parameter.Identifier.ValueText;
        var typeName = parameter.Type.ToString();
        
        // Check if this is a generic carrier type (typically 'TS' parameter)
        var isGenericCarrierType = IsGenericCarrierType(parameter.Type, semanticModel);
        
        return new SemanticParameterInfo(
            parameterName,
            typeName,
            isGenericCarrierType);
    }
    
    /// <summary>
    /// Gets the return type name for a method
    /// </summary>
    private static string GetReturnTypeName(TypeSyntax? returnType, SemanticModel semanticModel)
    {
        if (returnType == null)
            return "TR";
            
        return returnType.ToString();
    }
    
    /// <summary>
    /// Checks if a method has a generic type parameter (typically T)
    /// </summary>
    private static bool HasGenericTypeParameter(MethodDeclarationSyntax method, SemanticModel semanticModel)
    {
        // Check if method return type or parameters reference a generic type parameter
        // This is a simplified check - could be enhanced based on actual usage patterns
        var methodText = method.ToString();
        return methodText.Contains("TS") || methodText.Contains("<T>");
    }
    
    /// <summary>
    /// Checks if a type is a generic carrier type (like TS in the semantic interface)
    /// </summary>
    private static bool IsGenericCarrierType(TypeSyntax type, SemanticModel semanticModel)
    {
        var typeName = type.ToString();
        return typeName == "TS" || typeName.StartsWith("T") && typeName.Length <= 3;
    }
}

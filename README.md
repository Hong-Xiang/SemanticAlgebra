# SemanticAlgebra
Library for generalized object algebra and lightweight higher-kinded type for dotnet

WARNING: this doc is working in progress and contains contents generated by Copilot, may not be accurate.

<!-- Generated by Copilot -->
## Introduction

SemanticAlgebra provides a type-safe encoding of higher-kinded types (generics over generics) in C#, which doesn't natively support this concept. The library enables functional programming patterns like Functors, Applicatives, and Monads through semantic encoding of algebraic structures.

Using this library, you can:
- Create composable, type-safe data transformations
- Implement functional programming patterns in C#
- Build embedded domain-specific languages (DSLs)
- Support complex type operations with minimal boilerplate

## Encoding Higher Kinded Types

C# does not natively support higher-kinded types (HKTs) like `F<T>` where `F` itself is a type parameter. This limitation makes it challenging to implement functional programming abstractions that work across different container types.

### Core Encoding Strategy

The library uses the following pattern for encoding higher-kinded types:

```csharp
// Encoding f s -> r (a higher-kinded function)
public interface ISemantic1<out TF, in TS, out TR>
    where TF : IKind1<TF>
{
}

// Encoding f s (a "type application")
public interface IS<F, T>
{
    R Evaluate<R>(ISemantic1<F, T, R> semantic);
}
```

### Examples of HKT Encoding

The library provides implementations for common functional patterns:

```csharp
// Functor interface
public interface IFunctor<TF> : IKind1<TF>
    where TF : IFunctor<TF>
{
    // (s -> r) -> (f s -> f r)
    static abstract ISemantic1<TF, TS, IS<TF, TR>> MapS<TS, TR>(Func<TS, TR> f);
}

// Monadic operations
public static IS<TF, TR> SelectMany<TF, TS, TR>(this IS<TF, TS> fs, Func<TS, IS<TF, TR>> f)
    where TF : IMonad<TF>
    => fs.Select(f).Evaluate(TF.JoinS<TR>());
```

### Practical Example: Identity Monad

Here's how the Identity monad is implemented using this encoding:

```csharp
// Identity data type with Id constructor
sealed record class Id<T>(T Value) : IS<Identity, T>
{
    public TR Evaluate<TR>(ISemantic1<Identity, T, TR> semantic)
        => semantic.Prj().Unwrap(Value);
}

// Using the Identity monad
var idValue = Identity.Wrap(42);
var mapped = idValue.Select(x => x * 2);  // Id(84)
var result = mapped.Extract();  // 84
```

### Lambda Language Example

The library can be used to build embedded DSLs, as shown in this lambda calculus example:

```csharp
// Building a lambda expression
var S = Fix<Sig>.SyntaxFactory.Prj();
var x = new Identifier("x");
var add1 = S.Lambda(x, S.Add(S.LitI(1), S.Var(x)));

// Evaluating the expression
var result = expr.Fold<SigEvalData>(Sig.SigSemantic(
    new LitEvalFolder(),
    new ArithEvalFolder(),
    new LamEvalFolder(),
    new AppEvalFolder(),
    new BindEvalFolder()));
```

## Design Decisions

### Support for Value Types and `ref struct`

After experimentation, we found limitations when trying to fully support `ref struct` types with the previous encoding that included `ICoSemantic` and `IDiSemantic`. 

The core challenge is that `ref struct` types cannot be used as generic type parameters for an interface like `IS<F, T>` when `T` is a `ref struct`. This creates constraints when trying to return such types from functions.

While we can encode functions that accept `ref struct` types as parameters using constructs like `<TFT>Foo(TFT t) where TFT : IS<F, T>`, encoding functions that return such types would require existential types (`exist T. T Foo() where T : IS<F, T>`), which C# doesn't support.

Thus, we've simplified the library to focus on what works reliably with the current C# type system, removing `ICoSemantic` and `IDiSemantic` interfaces that were problematic with `ref struct` types.

## TypeScript Equivalent

As a comparasion, a TypeScript equivalent showing how the same concepts can be implemented in TypeScript:

```typescript
interface Kind1<F extends Kind1<F>> {
  readonly R?: unknown;
  readonly A?: unknown;
}

interface Exist1<FS extends Kind2<FS>> extends Kind1<Exist1<FS>> {
  readonly R: <R>(s: K2<FS, this["A"], R>) => R;
}

// Example of Option type
interface OptionSemantic<in TI, out TO> {
  readonly Some: (x: TI) => TO;
  readonly None: () => TO;
}

type Option = Exist1<OptionSemanticK2>;

// Pure function for Option
const OptionF: Pure<Option> = {
  pure: <A>(a: A) => <R>(s: OptionSemantic<A, R>) => s.Some(a),
};

// in Typescript, sub type relation is structural, so if semantic_a <: semantic_b, then its related expression Exist1<a> :> Exist1<b> is automatically satisfied.
// This is not the case in C#, so we need to use a manually marked `in/out F` in `IS` and `ISemantic1` respectively,
// which is not automatically checked by the compiler for correctness, we need to manully ensure that if brand F : G, then ISemantic<F, TI, TO> : ISemantic<G, TI, TO>.
```

## Further Reading

For more examples and advanced usage, see the test projects in the repository, particularly the LambdaLang example which demonstrates building a complete embedded DSL.

<!-- End of Copilot generated content -->
